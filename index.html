<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>AI Quiz-Generator</title>

    <script type="module">
      import zim from "https://zimjs.org/cdn/015/zim_three"; // also imports three.js R155

      async function fetchQuizzesStartingWith(key) {
        const response = await fetch(
          `https://fastapi-redis-crud.vercel.app/read_all_startwith?key=${encodeURIComponent(
            key
          )}`
        );
        zog(response);
        const data = await response.json();
        zog(data);
        return data;
      }

      async function generateQuizset(topic) {
        const response = await fetch(
          `https://langchainquizgenerator-ajerni.b4a.run/quiz_topic_json?thema=${encodeURIComponent(
            topic
          )}`,
          {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              accept: "application/json",
            },
            body: {},
          }
        )
          .then((response) => {
            response.json();
            zog("reached to here...");
            waiter.hide(); //TODO: get rid of waiter see below as well...
          })
          .then((data) => console.log(data))
          .catch((error) => console.error(error));
      }

      let message_nr;
      let frage_nr;
      let question = "";
      let answers = "";
      let correct_answer = "";
      let correct_answer_text = "";

      let score = 0;

      new Frame(
        FIT,
        1800,
        1200,
        darker,
        darker,
        ready,
        "maneblo_logo.png",
        "assets/"
      );

      async function ready() {
        const front = new TextureActive({
          width: W,
          height: H,
          color: white.toAlpha(0.8),
          corner: 20,
          // backingOrbit:false // if not wanting to orbitControl on backing
        }).addTo();

        // front content here:
        // let listOfTopics = await getAllToppics();
        // zog(listOfTopics);

        // Acordeon data:
        // var accordionData = {
        //   menu: {
        //     Topics: listOfTopics,
        //   },
        //   subStyles: [
        //     {
        //       backgroundColor: red,
        //       color: white,
        //       rollBackgroundColor: purple,
        //       rollColor: white,
        //       selectedBackgroundColor: white,
        //       selectedColor: red,
        //       selectedRollBackgroundColor: purple,
        //       selectedRollColor: white,
        //     },
        //   ],
        // };

        //List of topisc:
        // var list = new List({
        //   list: accordionData,
        //   titleBar: false,
        //   titleBarBackgroundColor: orange,
        //   titleBarColor: white,
        //   titleBarHeight: 40,
        //   scrollBarActive: true,
        //   currentSelected: false,
        //   indent: 20,
        //   height: 250,
        //   viewNum: 3,
        //   boundary: new Boundary(0, 0, W - 200, H - 200),
        //   borderWidth: -1,
        //   shadowBlur: -1,
        //   // backdropColor: F.color,
        //   // align:center,
        //   // backgroundColor:red,
        //   // color:black,
        //   // rollBackgroundColor:brown,
        //   // rollColor:black,
        //   // selectedBackgroundColor:black,
        //   // selectedColor:white,
        //   // selectedRollBackgroundColor:blue,
        //   // selectedRollColor:yellow
        // }).pos(750, 90, null, null, front);
        // list.selectedIndex = -1;

        //Ende Liste

        let themen_name_label = new Label({
          text: "Loaded: ", //TODO: das label platzieren...
          color: "#9A3C99",
        }).pos(430, 103, null, null, front);

        let themen_nr_label = new Label({
          text: "Topic:",
          color: "#9A3C99",
        }).pos(20, 103, null, null, front);

        let themen_nr_input = new Stepper({
          width: 70,
          height: 28,
          size: 28,
          min: 1,
          max: 99,
          color: "#9A3C99",
        }).pos(230, 91, null, null, front);

        let frage_nr_label = new Label({
          text: "Question:",
          color: "#9A3C99",
        }).pos(20, 175, null, null, front);

        let frage_nr_input = new Stepper({
          width: 70,
          height: 28,
          size: 28,
          min: 1,
          max: 99,
          color: "#9A3C99",
        }).pos(230, 164, null, null, front);

        let prevCorrLabels = [];

        //part for new topic to be generated on FastAPI
        let label_topic = new Label({
          text: "Enter new topic:",
          align: "right",
          color: "#9B3F9B",
        }).pos(240, 120, RIGHT, null, front);

        const input = new TextInput({
          width: 385,
          height: 60,
          placeholder: "...type here...",
          size: 36,
          align: "left",
        }).pos(110, 170, RIGHT, null, front);

        const waiter = new Waiter(front);

        function showChanges() {
          label_topic.text = "New topic received!";
          label_topic.color = "green";
          input.text = "";
          labes_topic.mov(80, 0);
          waiter.hide(front);
          waiter.removeFrom(front);
          S.update();
        }

        new Button(385, 60, "generate new topic")
          .pos(110, 250, RIGHT, null, front)
          .tap(async () => {
            zog(input.text);
            waiter.show();
            await generateQuizset(input.text);
            showChanges();
          });

        input.on("focus", () => {
          label_topic.text = "Enter new topic:";
          label_topic.color = "#9B3F9B";
        });

        //part for new question to be generated on FastAPI")

        //part to fetch questions from Redis
        new Button(785, 60, "Load Questions", "#4169E1")
          .pos(20, 250, null, null, front)
          .tap(async () => {
            prevCorrLabels.forEach((label) => {
              label.removeFrom(S.front);
            });
            prevCorrLabels = [];

            message_nr = themen_nr_input.currentValue - 1; // increase diffeentls 0-x (message sind die ganzen sets)
            frage_nr = frage_nr_input.currentValue - 1; // increase differntly 0-x (frage ist die einzelne set_nr)
            const quizzes = await fetchQuizzesStartingWith("json_quiz"); //liest alles aus von Redis, was mit "json_quiz" beginnt.
            //zog(JSON.stringify(quizzes));

            let selected_quizset =
              quizzes["messages"][message_nr]["Value"]["quizset"];

            //das quizset selber ist wiederum ein JSON objekt und muss deshalb geparsed werden:
            let parsed_quiz = JSON.parse(selected_quizset);
            question = parsed_quiz[frage_nr]["question"];

            answers = parsed_quiz[frage_nr]["answers"];
            correct_answer = parsed_quiz[frage_nr]["correct_answer"];
            correct_answer_text =
              parsed_quiz[frage_nr]["answers"][
                parsed_quiz[frage_nr]["correct_answer"]
              ];
            let thema = quizzes["messages"][message_nr]["Value"]["topic"]; //ist eine Stufe höher im ersten JSON
            themen_name_label.text = "Loaded: " + thema;

            function getAllTopics() {
              const messages = quizzes["messages"];
              const topics = [];

              for (let messageNr in messages) {
                const message = messages[messageNr];
                if (message && message["Value"]) {
                  topics.push(message["Value"]["topic"]);
                }
              }

              return topics;
            }

            const list_topics = getAllTopics();
            zog(getAllTopics());

            const list_topics_numbered = [];

            for (let i = 0; i < list_topics.length; i++) {
              list_topics_numbered.push(`${i + 1}) ${list_topics[i]}`);
            }

            //List of all topics:
            var list = new List({
              width: 200,
              height: 400,
              align: "left", // if aligned right indent should be 0 and labelIndent 10 (for center it does not matter)
              indent: 10, // otherwise when custom object is added the list takes on an outer indent
              labelIndent: 10, // if we do not want an outer indent we set it to 0 and but then need a labelIndent
              borderColor: light,
              viewNum: 8,
              corner: 10,
              list: list_topics_numbered,
              titleBar: "Topics",
              titleBarBackgroundColor: light,
              scrollBarActive: true,
              close: true,
              currentSelected: true,
              // boundary: new Boundary(5, 5, W - 215, H - 400 - 70), // height of List and other list
            })
              .pos(0, 100, CENTER, TOP, front)
              .change(function (e) {
                // zog(e.target.text);
                zog(e.target.selectedIndex);
                // list1.selectedIndex = e.target.selectedIndex; // no movement
                // list1.selectedIndexPlusPosition = e.target.selectedIndex; // directly to middl
              });

            themen_nr_input.on("change", () => {
              zog("Topic Nr. changed...");
              list.selectedIndex = themen_nr_input.currentValue - 1;
              S.update();
            });

            list.on("change", () => {
              zog("List index changed...");
              themen_nr_input.currentValue = list.selectedIndex + 1;
              S.update();
            });

            //main labesl etc.
            label_question.text = question;

            let result_answers_strings = "";

            for (let key in answers) {
              result_answers_strings += `${key}) ${answers[key]} \n`;
            }

            label_answers.text = result_answers_strings;

            let xpos = -125;

            // Remove any previous correction labels before creating new ones
            prevCorrLabels.forEach((label) => {
              label.removeFrom(S);
            });
            prevCorrLabels = [];

            for (let key in answers) {
              // Create a new label for the current answer
              let answerLabel = new Label({
                text: `${key}`,
                color: "white",
                bold: true,
                backgroundColor: "#4B0082",
                size: 80,
              }).hov("#6AB04D");
              answerLabel.center(front).mov(xpos, 260);

              // Add a tap event listener to the label
              answerLabel.expand().tap({
                once: true,
                call: () => {
                  // Remove any previous correction labels
                  prevCorrLabels.forEach((label) => {
                    label.removeFrom(S.front);
                  });
                  prevCorrLabels = [];

                  // Check if the label is correct
                  if (key === correct_answer) {
                    zog("Richtig!");

                    // Create a new correction label
                    let corrLabel = new Label({
                      text: "C O R R E C T  !",
                      color: "#3eaf1f",
                      bold: true,
                      size: 46,
                    });
                    corrLabel.pos(760, 130, LEFT, BOTTOM, front);
                    score += 1;
                    label_score.text = "Score: " + score;
                    S.update();
                    prevCorrLabels.push(corrLabel);
                  } else {
                    zog("Falsch!");

                    // Create a new correction label
                    let corrLabel = new Label({
                      text: "W R O N G  !",
                      color: red,
                      bold: true,
                      size: 46,
                    });
                    corrLabel.pos(800, 130, LEFT, BOTTOM, front);
                    S.update();
                    prevCorrLabels.push(corrLabel);
                  }
                },
              });

              xpos += 150;
            }

            S.update();
          });

        let label_question = new Label({
          text: question,
          align: "left",
          color: "#4B0082",
        })
          .pos(50, 390, null, null, front)
          .sca(1.4);
        // .transform({ container: front });

        let label_answers = new Label({
          text: answers,
          align: "left",
          color: "#4B0082",
        })
          .pos(50, 510, null, null, front)
          .sca(1.4);
        // .transform({ container: front });

        let label_score = new Label({
          text: "Score: " + score,
          align: "center",
          color: "#4B0082",
          size: 36,
          bold: true,
        }).pos(20, 27, "center", null, front);

        let label_title = new Label({
          text: "AI Quiz-Generator",
          align: "left",
          color: "white",
          bold: true,
          size: 48,
          outlineColor: "#4169E1",
        }).pos(20, 20, null, null, front);

        new Button(385, 60, "FastAPI Backend")
          .pos(110, 20, RIGHT, TOP, front)
          .tap(() => {
            zgo("https://langchainquizgenerator-ajerni.b4a.run/docs", "_blank");
          });

        // BACK OF PANEL

        const backing = new TextureActive({
          width: front.width,
          height: front.height,
          color: black,
          corner: 20,
          animated: false,
          interactive: false,
        }).addTo();

        new Pic("maneblo_logo.png").center(backing);

        //TextureActive.makeBacking(backing.width, backing.height).addTo(backing); // CANVAS WINDOW

        const three = new Three({
          width: window.innerWidth,
          height: window.innerHeight,
          cameraPosition: new THREE.Vector3(0, 0, 500),
          textureActive: true,
        });

        const renderer = three.renderer;
        const scene = three.scene;
        const camera = three.camera;

        // SKYBOX
        const skyTexture = new THREE.TextureLoader().load("assets/sky.jpg");
        const skyBoxGeometry = new THREE.SphereGeometry(100000, 32, 32);
        const skyBoxMaterial = new THREE.MeshBasicMaterial({
          map: skyTexture,
          side: THREE.BackSide,
        });
        const skyBox = new THREE.Mesh(skyBoxGeometry, skyBoxMaterial);
        scene.add(skyBox);

        // CONTROLS
        const controls = new OrbitControls(camera, three.canvas);

        const textureActives = new TextureActives(
          [front, backing],
          THREE,
          three,
          renderer,
          scene,
          camera,
          controls,
          1,
          0,
          1000
        );

        // const canvasWindow = three.makePanel(front, textureActives, null, -50);
        const canvasWindow = three.makePanel(front, textureActives, null, 0);
        scene.add(canvasWindow);

        // BACKING MESH
        const canvasWindowBacking = three.makePanel(
          backing,
          textureActives,
          null,
          0, //-50 wenn der gebogene Effekt gewünscht...
          0.5
        ); // transparent and alpha
        scene.add(canvasWindowBacking);
        canvasWindowBacking.rotation.y = 180 * RAD; // flip it around the other way (RAD is ZIM constant for converting, DEG is the otherway)

        let fps;
        const fpsT = Ticker.add(() => {
          fps = Ticker.getFPS();
        });
        timeout(2, () => {
          if (fps < 50) {
            Ticker.setFPS(30);
          }
          Ticker.remove(fpsT);
        });
      }
    </script>
    <meta name="viewport" content="width=device-width, user-scalable=no" />
  </head>
  <body></body>
</html>
