<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>AI Quiz-Generator</title>

    <script type="module">
      import zim from "https://zimjs.org/cdn/015/zim_three"; // also imports three.js R155

      async function fetchQuizzesStartingWith(key) {
        const response = await fetch(
          `https://fastapi-redis-crud.vercel.app/read_all_startwith?key=${encodeURIComponent(
            key
          )}`
        );
        zog(response);
        const data = await response.json();
        zog(data);
        return data;
      }

      function replaceQuotes(str) {
        return str.replace(/'/g, '"');
      }

      function formatNumbers(str) {
        return str.replace(/(?<![\d])[1-9](?!\w)/g, function (match) {
          return `'${match}'`;
        });
      }

      async function generateQuizset(topic) {
        const response = await fetch(
          `https://langchainquizgenerator-ajerni.b4a.run/quiz_topic?thema=${encodeURIComponent(
            topic
          )}`,
          {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              // "Access-Control-Allow-Origin": "*",
            },
            body: {},
          }
        )
          .then((response) => response.json())
          .then((data) => console.log(data))
          .catch((error) => console.error(error));
      }

      let message_nr;
      let frage_nr;
      let question = "";
      let answers = "";
      let correct_answer = "";
      let correct_answer_text = "";

      let score = 0;

      new Frame(
        FIT,
        1800,
        1200,
        darker,
        darker,
        ready,
        "maneblo_logo.png",
        "assets/"
      );

      function ready() {
        const front = new TextureActive({
          width: W,
          height: H,
          color: white.toAlpha(0.8),
          corner: 20,
          // backingOrbit:false // if not wanting to orbitControl on backing
        }).addTo();

        // front content here:
        let themen_nr_label = new Label({
          text: "Topic:",
          color: "#9A3C99",
        }).pos(20, 103, null, null, front);

        let themen_nr_input = new Stepper({
          width: 70,
          height: 28,
          size: 28,
          min: 1,
          max: 99,
          color: "#9A3C99",
        }).pos(230, 91, null, null, front);

        let frage_nr_label = new Label({
          text: "Question:",
          color: "#9A3C99",
        }).pos(20, 175, null, null, front);

        let frage_nr_input = new Stepper({
          width: 70,
          height: 28,
          size: 28,
          min: 1,
          max: 99,
          color: "#9A3C99",
        }).pos(230, 164, null, null, front);

        let prevCorrLabels = [];

        //part for new topic to be generated on FastAPI
        let label_topic = new Label({
          text: "Press 't' to enter",
          align: "right",
          color: "#9B3F9B",
        }).pos(240, 120, RIGHT, null, front);

        const input = new TextInput({
          width: 385,
          height: 60,
          placeholder: "new topic here",
          size: 36,
          align: "left",
        }).pos(110, 170, RIGHT, null, front);

        new Button(385, 60, "generate new topic")
          .pos(110, 250, RIGHT, null, front)
          .tap(async () => {
            zog(input.text);
            await generateQuizset(input.text);
          });

        //part to fetch questions from Redis
        new Button(385, 60, "GET QUESTIONS", "#4169E1")
          .pos(20, 250, null, null, front)
          .tap(async () => {
            prevCorrLabels.forEach((label) => {
              label.removeFrom(S.front);
            });
            prevCorrLabels = [];

            message_nr = themen_nr_input.currentValue - 1; // increase diffeentls 0-x (message sind die ganzen sets)
            frage_nr = frage_nr_input.currentValue - 1; // increase differntly 0-x (frage ist die einzelne set_nr)
            const quizzes = await fetchQuizzesStartingWith("quiz");
            console.log(quizzes);

            let formated = formatNumbers(
              quizzes["messages"][message_nr]["Value"]
            );

            console.log(replaceQuotes(formated));

            let selected_set = JSON.parse(replaceQuotes(formated));

            console.log(selected_set[frage_nr].question);
            console.log(selected_set[frage_nr].answers);
            console.log(selected_set[frage_nr].correct_answer);
            console.log(
              selected_set[frage_nr].answers[
                selected_set[frage_nr].correct_answer
              ]
            );

            question = selected_set[frage_nr].question;
            answers = selected_set[frage_nr].answers;
            correct_answer = selected_set[frage_nr].correct_answer;
            correct_answer_text =
              selected_set[frage_nr].answers[
                selected_set[frage_nr].correct_answer
              ];
            label_question.text = question;

            let result_answers_strings = "";

            for (let key in answers) {
              result_answers_strings += `${key}) ${answers[key]} \n`;
            }

            label_answers.text = result_answers_strings;

            let xpos = -200;

            // Remove any previous correction labels before creating new ones
            prevCorrLabels.forEach((label) => {
              label.removeFrom(S);
            });
            prevCorrLabels = [];

            for (let key in answers) {
              // Create a new label for the current answer
              let answerLabel = new Label({
                text: `${key}`,
                color: "white",
                bold: true,
                backgroundColor: "#4B0082",
                size: 80,
              }).hov("#6AB04D");
              answerLabel.center(front).mov(xpos, 260);

              // Add a tap event listener to the label
              answerLabel.expand().tap({
                once: true,
                call: () => {
                  // Remove any previous correction labels
                  prevCorrLabels.forEach((label) => {
                    label.removeFrom(S.front);
                  });
                  prevCorrLabels = [];

                  // Check if the label is correct
                  if (key === correct_answer) {
                    zog("Richtig!");

                    // Create a new correction label
                    let corrLabel = new Label({
                      text: "C O R R E C T  !",
                      color: "#3eaf1f",
                      bold: true,
                      size: 46,
                    });
                    corrLabel.pos(760, -444, LEFT, CENTER, front);
                    score += 1;
                    label_score.text = "Score: " + score;
                    S.update();
                    prevCorrLabels.push(corrLabel);
                  } else {
                    zog("Falsch!");

                    // Create a new correction label
                    let corrLabel = new Label({
                      text: "W R O N G  !",
                      color: red,
                      bold: true,
                      size: 46,
                    });
                    corrLabel.pos(760, -444, LEFT, CENTER, front);
                    S.update();
                    prevCorrLabels.push(corrLabel);
                  }
                },
              });

              xpos += 150;
            }

            S.update();
          });

        let label_question = new Label({
          text: question,
          align: "left",
          color: "#4B0082",
        }).pos(20, 340, null, null, front);

        let label_answers = new Label({
          text: answers,
          align: "left",
          color: "#4B0082",
        }).pos(20, 410, null, null, front);

        let label_score = new Label({
          text: "Score: " + score,
          align: "center",
          color: "#4B0082",
          size: 36,
          bold: true,
        }).pos(20, 27, "center", null, front);

        let label_title = new Label({
          text: "AI Quiz-Generator",
          align: "left",
          color: "white",
          bold: true,
          size: 48,
          outlineColor: "#4169E1",
        }).pos(20, 20, null, null, front);

        new Button(385, 60, "FastAPI Backend")
          .pos(110, 20, RIGHT, TOP, front)
          .tap(() => {
            zgo("https://langchainquizgenerator-ajerni.b4a.run/docs", "_blank");
          });

        // BACK OF PANEL

        const backing = new TextureActive({
          width: front.width,
          height: front.height,
          color: black,
          corner: 20,
          animated: false,
          interactive: false,
        }).addTo();

        new Pic("maneblo_logo.png").center(backing);

        //TextureActive.makeBacking(backing.width, backing.height).addTo(backing); // CANVAS WINDOW

        const three = new Three({
          width: window.innerWidth,
          height: window.innerHeight,
          cameraPosition: new THREE.Vector3(0, 0, 500),
          textureActive: true,
        });

        const renderer = three.renderer;
        const scene = three.scene;
        const camera = three.camera;

        // SKYBOX
        const skyTexture = new THREE.TextureLoader().load("assets/sky.jpg");
        const skyBoxGeometry = new THREE.SphereGeometry(100000, 32, 32);
        const skyBoxMaterial = new THREE.MeshBasicMaterial({
          map: skyTexture,
          side: THREE.BackSide,
        });
        const skyBox = new THREE.Mesh(skyBoxGeometry, skyBoxMaterial);
        scene.add(skyBox);

        // CONTROLS
        const controls = new OrbitControls(camera, three.canvas);

        const textureActives = new TextureActives(
          [front, backing],
          THREE,
          three,
          renderer,
          scene,
          camera,
          controls,
          1,
          0,
          1000
        );

        // can capture raydown, raymove, rayup, rayover and rayout
        textureActives.on("raymove", (e) => {
          // zog(e.intersect.distance);
        });

        // const canvasWindow = three.makePanel(front, textureActives, null, -50);
        const canvasWindow = three.makePanel(front, textureActives, null, 0);
        scene.add(canvasWindow);

        // BACKING MESH
        const canvasWindowBacking = three.makePanel(
          backing,
          textureActives,
          null,
          0, //-50 wenn der gebogene Effekt gewünscht...
          0.5
        ); // transparent and alpha
        scene.add(canvasWindowBacking);
        canvasWindowBacking.rotation.y = 180 * RAD; // flip it around the other way (RAD is ZIM constant for converting, DEG is the otherway)

        let fps;
        const fpsT = Ticker.add(() => {
          fps = Ticker.getFPS();
        });
        timeout(2, () => {
          if (fps < 50) {
            Ticker.setFPS(30);
          }
          Ticker.remove(fpsT);
        });
      }
    </script>
    <meta name="viewport" content="width=device-width, user-scalable=no" />
  </head>
  <body></body>
</html>
